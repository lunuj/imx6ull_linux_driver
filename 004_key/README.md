# Q&A

1. 应用程序中selet时如何进行非阻塞的IO调用？
- 答：首尾两次查询状态信息，应用层APP调用selet时会最终调用内核中驱动程序的poll函数，当首次进入select时，调用poll函数查询状态信息；当select将要超时退出时再次调用poll函数查询状态信息。

2. poll函数中poll_wait所起到的作用是什么？
- 答：应用层APP调用selet时中间会进入阻塞不占用CPU，而此时如果检测事件发生，如外部中断等信息，需要等待唤醒事件发生时及时响应，poll_wait就是将等待队列和poll_table关联起来。

# BUG

1. 按下按键不释放，为何wake_up等待队列后再次进入poll函数后调用poll_wait函数时会直接通过不再等待
- 答：poll_wait只是关联等待队列和poll_table，并无实际阻塞功能，之所以不再等待是因为按键值一直有效，所以不再等待，解决方案时检测按键的触发状态而非按键值。同时发现一个bug，在定时器处理函数中进行按键值处理时，由于定时器处理函数是由中断触发，导致按键值处理函数不能一直运行，不会出现按键按下但未触发的状态.

2. 按下按键不释放，只触发了定时器处理函数，未对等待队列进行调度
- 答：原因是按键按下时，按键的触发值为0，使用gpio_get_value获取按键值时0表示按下，1表示释放，需要做转换。

3. 释放按键未正确返回返回按键值
- 答：按键扫描部分的bug导致，在原本逻辑中，只有按键值有效才计算触发，现修改为无论按键值是否有效都对触发进行计算。